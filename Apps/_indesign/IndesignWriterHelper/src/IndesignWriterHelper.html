<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EnneadTab InDesign Writer Helper</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Floating Logo -->
    <div id="floatingLogo" class="floating-logo">
        <img src="logo_vertical_light.png" alt="EnneadTab Logo" />
    </div>

    <div class="container">
        <div class="header">
            <h1>EnneadTab InDesign Writer Helper</h1>
            <p>Professional Text Management Tool for InDesign Documents</p>
        </div>

        <div class="content">
            <div id="status" class="status info">
                Ready to connect to InDesign
            </div>

            <!-- Connect to InDesign -->
            <div class="step">
                <h3>Connect to InDesign</h3>
                <p>Detect and connect to your InDesign application. Make sure InDesign is open with your document.</p>
                
                <!-- Auto-connect option -->
                <div class="auto-connect-section">
                    <h4>Quick Connect (Recommended)</h4>
                    <p>Automatically connect to your currently open InDesign and active documents.</p>
                    <button id="autoConnectBtn" class="btn btn-success btn-rectangular">
                        Detect InDesign & Open Documents
                    </button>
                    <div id="autoConnectLoading" class="loading">
                        <div class="spinner"></div>
                        <p>Auto-connecting to InDesign...</p>
                    </div>
                    
                    <!-- Auto-detection status -->
                    <div id="autoDetectionStatus" class="auto-detection-status">
                        <span id="autoDetectionText">Auto-detecting InDesign every 1 second...</span>
                        <button id="stopAutoDetectionBtn" class="btn" style="margin-left: 8px; padding: 4px 8px; font-size: 0.8em;">Stop</button>
                    </div>
                </div>
                
                <div class="divider">
                    <span>- OR -</span>
                </div>
                
                <!-- Manual connect option -->
                <button id="detectVersionsBtn" class="btn btn-rectangular">Detect InDesign Versions</button>
                <div id="detectLoading" class="loading">
                    <div class="spinner"></div>
                    <p>Detecting InDesign versions...</p>
                </div>
                
                <div id="versionSelection" class="hidden">
                    <div class="form-group">
                        <label for="indesignVersion">Select InDesign Version:</label>
                        <select id="indesignVersion">
                            <option value="">Loading versions...</option>
                        </select>
                    </div>
                    <button id="connectBtn" class="btn btn-success btn-rectangular">Connect to Selected Version</button>
                    <div id="connectLoading" class="loading">
                        <div class="spinner"></div>
                        <p>Connecting to InDesign...</p>
                    </div>
                </div>
            </div>

            <!-- Main Application Interface -->
            <div id="mainInterface" class="hidden">
                <!-- Document Info Display -->
                <div id="documentInfo" class="document-info">
                    <div class="document-info-content">
                        <div class="document-icon">üìÑ</div>
                        <div class="document-info-text">
                            <div class="document-label">Current Document:</div>
                            <div class="document-name" id="documentName">No document loaded</div>
                            <div class="document-path" id="documentPath">-</div>
                        </div>
                    </div>
                </div>

                <!-- Main Application Layout -->
                <div class="main-container">
                    <!-- Sidebar -->
                    <div class="sidebar">
                        <div class="sidebar-header">
                            <h3>Document Statistics</h3>
                            <div class="stats-grid">
                                <div class="stat-item">
                                    <span class="stat-value" id="totalFrames">0</span>
                                    <div class="stat-label">Text Frames</div>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-value" id="totalPages">0</span>
                                    <div class="stat-label">Pages</div>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-value" id="currentFrame">0</span>
                                    <div class="stat-label">Current Frame</div>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-value" id="currentPage">1</span>
                                    <div class="stat-label">Current Page</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Navigation Panel -->
                    <div class="navigation-panel">
                        <!-- Navigation Controls -->
                        <div class="navigation-controls">
                            <button id="prevFrameBtn" class="nav-btn" disabled>‚Üê Previous</button>
                            <button id="nextFrameBtn" class="nav-btn" disabled>Next ‚Üí</button>
                            
                            <div class="page-selector">
                                <label for="pageSelect">Page:</label>
                                <select id="pageSelect">
                                    <option value="">Loading pages...</option>
                                </select>
                            </div>
                            
                            <div class="search-box">
                                <input type="text" id="searchInput" placeholder="Search text content...">
                            </div>
                        </div>

                        <!-- Frame Information -->
                        <div id="frameInfo" class="frame-info">
                            <span class="frame-number">Frame: <span id="frameNumber">-</span></span>
                            <span class="frame-page">Page: <span id="framePage">-</span></span>
                            <span class="frame-count">(<span id="frameCount">0</span> total frames)</span>
                        </div>

                        <!-- Text Area -->
                        <textarea id="textArea" class="text-area" placeholder="Text content will appear here..." readonly></textarea>

                        <!-- Toolbar -->
                        <div class="toolbar">
                            <button id="copyBtn" class="toolbar-btn" disabled>Copy Text</button>
                            <button id="saveBtn" class="toolbar-btn" disabled>Save Changes</button>
                            <button id="refreshBtn" class="toolbar-btn">Refresh</button>
                            <button id="exportBtn" class="toolbar-btn" disabled>Export All</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentFrameIndex = 0;
        let totalFrames = 0;
        let frames = [];
        let currentPage = 1;
        let pages = [];
        let isConnected = false;

        // DOM elements
        const statusDiv = document.getElementById('status');
        const autoConnectBtn = document.getElementById('autoConnectBtn');
        const detectVersionsBtn = document.getElementById('detectVersionsBtn');
        const connectBtn = document.getElementById('connectBtn');
        const mainInterface = document.getElementById('mainInterface');
        const textArea = document.getElementById('textArea');
        const frameInfo = document.getElementById('frameInfo');
        const prevFrameBtn = document.getElementById('prevFrameBtn');
        const nextFrameBtn = document.getElementById('nextFrameBtn');
        const pageSelect = document.getElementById('pageSelect');
        const searchInput = document.getElementById('searchInput');
        const copyBtn = document.getElementById('copyBtn');
        const saveBtn = document.getElementById('saveBtn');
        const refreshBtn = document.getElementById('refreshBtn');
        const exportBtn = document.getElementById('exportBtn');

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            autoConnectBtn.addEventListener('click', autoConnect);
            detectVersionsBtn.addEventListener('click', detectVersions);
            connectBtn.addEventListener('click', connectToVersion);
            prevFrameBtn.addEventListener('click', previousFrame);
            nextFrameBtn.addEventListener('click', nextFrame);
            pageSelect.addEventListener('change', jumpToPage);
            searchInput.addEventListener('input', searchText);
            copyBtn.addEventListener('click', copyText);
            saveBtn.addEventListener('click', saveChanges);
            refreshBtn.addEventListener('click', refreshData);
            exportBtn.addEventListener('click', exportAllText);
        });

        // Auto-connect to InDesign
        async function autoConnect() {
            updateStatus('Auto-connecting to InDesign...', 'info');
            showLoading('autoConnectLoading', true);
            
            try {
                const response = await fetch('/api/auto_connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                
                const data = await response.json();
                
                if (data.success) {
                    updateStatus('Successfully connected to InDesign!', 'success');
                    isConnected = true;
                    loadDocumentData();
                } else {
                    updateStatus('No running InDesign instance found. Please start InDesign first.', 'error');
                }
            } catch (error) {
                updateStatus('Connection failed: ' + error.message, 'error');
            } finally {
                showLoading('autoConnectLoading', false);
            }
        }

        // Detect InDesign versions
        async function detectVersions() {
            updateStatus('Detecting InDesign versions...', 'info');
            showLoading('detectLoading', true);
            
            try {
                const response = await fetch('/api/detect_versions');
                const data = await response.json();
                
                if (data.success && data.versions.length > 0) {
                    populateVersionSelect(data.versions);
                    document.getElementById('versionSelection').classList.remove('hidden');
                    updateStatus('InDesign versions detected. Select a version to connect.', 'success');
                } else {
                    updateStatus('No InDesign versions found. Please install InDesign.', 'error');
                }
            } catch (error) {
                updateStatus('Version detection failed: ' + error.message, 'error');
            } finally {
                showLoading('detectLoading', false);
            }
        }

        // Connect to specific version
        async function connectToVersion() {
            const version = document.getElementById('indesignVersion').value;
            if (!version) {
                updateStatus('Please select an InDesign version.', 'error');
                return;
            }
            
            updateStatus('Connecting to InDesign...', 'info');
            showLoading('connectLoading', true);
            
            try {
                const response = await fetch('/api/connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ version: version })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    updateStatus('Successfully connected to InDesign!', 'success');
                    isConnected = true;
                    loadDocumentData();
                } else {
                    updateStatus('Failed to connect to InDesign.', 'error');
                }
            } catch (error) {
                updateStatus('Connection failed: ' + error.message, 'error');
            } finally {
                showLoading('connectLoading', false);
            }
        }

        // Load document data
        async function loadDocumentData() {
            try {
                const response = await fetch('/api/document_info');
                const data = await response.json();
                
                if (data.success) {
                    updateDocumentInfo(data.document);
                    loadTextFrames();
                    mainInterface.classList.remove('hidden');
                } else {
                    updateStatus('No document is currently open in InDesign.', 'warning');
                }
            } catch (error) {
                updateStatus('Failed to load document info: ' + error.message, 'error');
            }
        }

        // Load text frames
        async function loadTextFrames() {
            try {
                const response = await fetch('/api/text_frames');
                const data = await response.json();
                
                if (data.success) {
                    frames = data.frames;
                    totalFrames = frames.length;
                    currentFrameIndex = 0;
                    
                    updateStatistics();
                    loadPages();
                    displayCurrentFrame();
                } else {
                    updateStatus('No text frames found in the document.', 'warning');
                }
            } catch (error) {
                updateStatus('Failed to load text frames: ' + error.message, 'error');
            }
        }

        // Load pages
        async function loadPages() {
            try {
                const response = await fetch('/api/pages');
                const data = await response.json();
                
                if (data.success) {
                    pages = data.pages;
                    populatePageSelect();
                }
            } catch (error) {
                console.error('Failed to load pages:', error);
            }
        }

        // Display current frame
        function displayCurrentFrame() {
            if (frames.length === 0) {
                textArea.value = 'No text frames available.';
                return;
            }
            
            const frame = frames[currentFrameIndex];
            textArea.value = frame.content || 'No text content.';
            
            document.getElementById('frameNumber').textContent = currentFrameIndex + 1;
            document.getElementById('framePage').textContent = frame.page || 'Unknown';
            document.getElementById('frameCount').textContent = totalFrames;
            
            updateNavigationButtons();
        }

        // Navigation functions
        function previousFrame() {
            if (currentFrameIndex > 0) {
                currentFrameIndex--;
                displayCurrentFrame();
            }
        }

        function nextFrame() {
            if (currentFrameIndex < totalFrames - 1) {
                currentFrameIndex++;
                displayCurrentFrame();
            }
        }

        function jumpToPage() {
            const selectedPage = pageSelect.value;
            if (selectedPage) {
                const pageFrames = frames.filter(frame => frame.page === selectedPage);
                if (pageFrames.length > 0) {
                    currentFrameIndex = frames.indexOf(pageFrames[0]);
                    displayCurrentFrame();
                }
            }
        }

        // Search functionality
        function searchText() {
            const searchTerm = searchInput.value.toLowerCase();
            if (searchTerm.length < 2) return;
            
            const foundFrame = frames.findIndex(frame => 
                frame.content && frame.content.toLowerCase().includes(searchTerm)
            );
            
            if (foundFrame !== -1) {
                currentFrameIndex = foundFrame;
                displayCurrentFrame();
                updateStatus(`Found text in frame ${foundFrame + 1}`, 'success');
            } else {
                updateStatus('No matching text found.', 'warning');
            }
        }

        // Utility functions
        function updateStatus(message, type) {
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
        }

        function showLoading(elementId, show) {
            const element = document.getElementById(elementId);
            if (show) {
                element.classList.add('show');
            } else {
                element.classList.remove('show');
            }
        }

        function updateDocumentInfo(document) {
            document.getElementById('documentName').textContent = document.name || 'Untitled';
            document.getElementById('documentPath').textContent = document.path || '-';
        }

        function updateStatistics() {
            document.getElementById('totalFrames').textContent = totalFrames;
            document.getElementById('totalPages').textContent = pages.length;
            document.getElementById('currentFrame').textContent = currentFrameIndex + 1;
            document.getElementById('currentPage').textContent = currentPage;
        }

        function updateNavigationButtons() {
            prevFrameBtn.disabled = currentFrameIndex === 0;
            nextFrameBtn.disabled = currentFrameIndex === totalFrames - 1;
            copyBtn.disabled = !textArea.value || textArea.value === 'No text content.';
            saveBtn.disabled = !textArea.value || textArea.value === 'No text content.';
            exportBtn.disabled = totalFrames === 0;
        }

        function populateVersionSelect(versions) {
            const select = document.getElementById('indesignVersion');
            select.innerHTML = '<option value="">Select InDesign version...</option>';
            versions.forEach(version => {
                const option = document.createElement('option');
                option.value = version;
                option.textContent = `InDesign ${version}`;
                select.appendChild(option);
            });
        }

        function populatePageSelect() {
            pageSelect.innerHTML = '<option value="">All pages</option>';
            pages.forEach(page => {
                const option = document.createElement('option');
                option.value = page;
                option.textContent = page;
                pageSelect.appendChild(option);
            });
        }

        // Toolbar functions
        function copyText() {
            textArea.select();
            document.execCommand('copy');
            updateStatus('Text copied to clipboard!', 'success');
        }

        async function saveChanges() {
            try {
                const response = await fetch('/api/update_text', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        frameIndex: currentFrameIndex,
                        content: textArea.value
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    updateStatus('Text changes saved successfully!', 'success');
                    frames[currentFrameIndex].content = textArea.value;
                } else {
                    updateStatus('Failed to save changes.', 'error');
                }
            } catch (error) {
                updateStatus('Save failed: ' + error.message, 'error');
            }
        }

        function refreshData() {
            if (isConnected) {
                loadDocumentData();
                updateStatus('Data refreshed.', 'success');
            } else {
                updateStatus('Not connected to InDesign.', 'error');
            }
        }

        async function exportAllText() {
            try {
                const response = await fetch('/api/export_text');
                const data = await response.json();
                
                if (data.success) {
                    // Create download link
                    const blob = new Blob([data.content], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'indesign_text_export.txt';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    updateStatus('Text exported successfully!', 'success');
                } else {
                    updateStatus('Export failed.', 'error');
                }
            } catch (error) {
                updateStatus('Export failed: ' + error.message, 'error');
            }
        }

        // Floating logo scroll effect
        let lastScrollTop = 0;
        window.addEventListener('scroll', function() {
            const st = window.pageYOffset || document.documentElement.scrollTop;
            const floatingLogo = document.getElementById('floatingLogo');
            
            if (st > lastScrollTop) {
                floatingLogo.classList.add('scrolling');
            } else {
                floatingLogo.classList.remove('scrolling');
            }
            
            lastScrollTop = st <= 0 ? 0 : st;
        });
    </script>
</body>
</html>
